% View- and Dependency Injection
% Patrick Sturm
% 12.10.2016

## Information

* Any issues with this presentation? Write a ticket or send me a pull request ;).
* Repo: [https://github.com/siyb/tw-fdpsm-1-depinjection](https://github.com/siyb/tw-fdpsm-1-depinjection)

# Agenda

## Agenda

* Recap: annotations
* ButterKnife
* Android Annotations
* dagger 2

## Recap: Annotations - 1 - Example: Declaration

```java
// accessiblity of annotation
@Retention(RetentionPolicy.RUNTIME)
// this annotation is only applicable to...
@Target(ElementType.FIELD)
// the actual annotation definition
public interface @MyAnnotation {
  // annotation parameter definition
  int someParameter() default 0;
}
```
## Recap Annotations - 2 - Example Explained

* Retention (can be left out):
    * SOURCE: annotation only available in source code (e.g.: compile time checks)
    * CLASS: default, available in class file and source code (e.g.: compile time checks in external lib)
    * RUNTIME: available at runtime, in class file and source code (everything that requires runtime checks)
* Target
   * Defines what kind of construct can be annotated using this annotation (can be left out)
   * Can be a number of things including: FIELD, METHOD and TYPE

## Recap Annotations - 3 - Example: Usage

```java
@MyAnnotation(1)
private Object testField;
```

## Recap Annotations - 4 - Example: Accessing Runtime Annotations

```java
MyAnnotation a = (MyAnnotation) myObject
  .getClass()
  .getDeclaredField("testField")
  .getAnnotation(MyAnnotation.class);		   
// getting our value!
a.testField();
```

## Butter Knife - 1 - Intro

* Butter Knife could be described as a micro framework
* It does two things (and does them well):
    * Resource Injection
    * Listener Bindings
* Uses code generation, older versions rely on reflections
* If you want something more sophisticated and less focused, AndroidAnnotations / Dagger 2 might be more to your liking

## Butter Knife - 2 - Supported Annotations

* Butter Knife supports the following Annotations:
    * @BindView: allows view bindings
    * @Bind[Drawable,Bool,Color,Dimen,Int,String]: binds resource type
    * @OnClick: mark method as click listener for specified button

## Butter Knife - 3 - Mechanism

* ButterKnife generates glue code for you.
* In order to make Butter Knife aware of the annotations, we need to manually bind Butter Knife to the component in question, likewise, we need to unbind Butter Knife when we are done (Fragments)
    * By calling `bind`, you are delegating the binding process to the code generated by ButterKnife
* Use: ButterKnife.bind(targetClass), ButterKnife.unbind(targetClass), Butter Knife also supports providing Activities, Dialogs and Views as secondary parameters, which is important if we want to bind views of Fragments!
* Please note that fields, which we want to inject using Butter Knife must not be `private`

## Butter Knife - 4 - Mechanism cont.

Taken From: [http://jakewharton.github.io/butterknife/](http://jakewharton.github.io/butterknife/)

```java
public void bind(ExampleActivity activity) {
  activity.subtitle = 
    (android.widget.TextView) activity.findViewById(2130968578);
  activity.footer = 
    (android.widget.TextView) activity.findViewById(2130968579);
  activity.title = 
    (android.widget.TextView) activity.findViewById(2130968577);
}
```

# [ButterKnife - CODE EXAMPLE!](https://github.com/SphericalElephant/android-example-butterknife)

# AndroidAnnotations

## AndroidAnnotations - 1 - Introduction

* AndroidAnnotations support a number of different features, including view injection and listener binding!
* Not as focused as Butter Knife:
    * Supports "real" dependency injection and resource injection
    * Supports event binding
    * Thread binding
    * REST API binding
    * Android Preference API helpers / typesafty

## AndroidAnnotations - 2 - Introduction cont.

* Since AndroidAnnotations is a very large framework, we will not cover everything here
* We will only cover view injection and event binding
* Unlike other Android frameworks, AndroidAnnotations is well documented
* Uses code generation
* See these resources for more information on the topic [here](https://github.com/excilys/androidannotations/wiki/AvailableAnnotations)

## AndroidAnnotations - 3 - Introduction cont.

* Unlike Butter Knife, which needs to be bound manually, AndroidAnnotations will generate code from annotated classes
* That also means that we need to be careful when calling our components in Java code or XML.
    * Our Activity / Fragment / Service / ContentProvider / etc is not the one that will be used during runtime, we need to reference the actual component by denoting (postfixing) it with an "\_", MainActivity.class becomes MainActivity\_.class, even in AndroidManifest.xml declaration!
* Generated files can be found in build/generated/source/apt/debug

## AndroidAnnotations - 4 - Injection

* AndroidAnnotations features a set of annotations to make the framework recognize these classes as annotated (Enhanced Components)
* Please note that fields, which we want to inject using AndroidAnnotations must not be `private`

## AndroidAnnotations - 5 - Annotations

* We will cover all annotations that allow us to mimic the behavior of Butter Knife:
    * @ViewById: corresponds to @BindView
    * @Click: corresponds to @OnClick
    * @[]Res: Corresponds to @Bind[]

# [AndroidAnnotations - CODE EXAMPLE!](https://github.com/SphericalElephant/android-example-androidannotations)

# Dagger

## Dagger- 1 - Introduction

* We are only looking at Dagger 2 today
* Relies on code generation
* Uses annotations to inject instances
* Very similar to what you know from Java DPI (javax.inject.*) or guice
* Somewhat different to AndroidAnnotations and ButterKnife
    * No android specific dependency injection
* Injected fields must not be private

## Dagger - 2 - Annotations: @Inject

* @Inject - inject an instance (Dagger uses the javax.inject.Inject Annotation!)
* Supports field, ctor and method injection
* Preferred: field and ctor (some people argue that you should only use ctor injections in order to tell the user, which dependencies are required for manual instantiation)
* If you are using field injections, Dagger will not create new instances
    * Add a no parameter ctor and annotate it with @Inject in order to tell Dagger to initialize dependencies
* Default behaviour: @Inject -> new MyClass();

## Dagger - 3 - Example: @Inject

```java
public class MyClass {
  @Inject
  private Mydependecy;

  @Inject
  public MyClass() {
  }
}
```

## Dagger - 4 - Annotations: @Provides

* @Provides - provide instances to be injected
* To be used when you want to inject:
    * Interface implementations
    * 3rd party stuff
    * Complex objects that to be set up
* Use it to annotate methods, the return type of the method is the one that is provided
* Methods annotated with the @Provides annotation must be part of a @Module
* ... they can also have other dependencies!

## Dagger - 5 - Example: @Provides

```java
@Module
public class MyModule {
  @Provides
  public static MyDependency provideMyDependency() {
      MyDependency res = new MyDependecy();
      res.setName("Test");
      return res;
  }
  @Provides
  public static MyOtherDependency 
    provideMyOtherDependency(MyDependency myDependency) {
      MyOtherDependency res = new MyOtherDependency();
      res.setMyDependency(myDependency);
      return res;
  }
}
```

## Dagger - 6 - Annotations: @Singleton

* @Singleton - provide a singleton instance (Dagger uses the javax.inject.Singleton Annotation!)
* Used in conjunction with @Provides or at a class annotation (injectable class)


# Any Questions?